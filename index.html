<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Questionnaire System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            line-height: 1.6;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #000;
            padding-bottom: 20px;
        }
        
        .header h1 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .upload-section {
            text-align: center;
            padding: 40px;
        }
        
        .upload-box {
            border: 3px dashed #2196f3;
            padding: 40px;
            border-radius: 5px;
            background-color: #f0f8ff;
            margin-bottom: 30px;
            cursor: pointer;
        }
        
        .upload-box:hover {
            background-color: #e3f2fd;
        }
        
        .upload-box h2 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #1976d2;
        }
        
        .upload-box p {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .config-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .config-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .config-field label {
            font-weight: bold;
            font-size: 14px;
        }
        
        .config-field input,
        .config-field select,
        .config-field textarea {
            padding: 8px;
            font-family: Arial, sans-serif;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .config-field textarea {
            resize: vertical;
            min-height: 60px;
        }
        
        .checkboxes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 30px;
        }
        
        .btn {
            flex: 1;
            padding: 12px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            transition: background-color 0.2s;
        }
        
        .btn-primary {
            background-color: #2196f3;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #1976d2;
        }
        
        .btn-success {
            background-color: #4caf50;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #45a049;
        }
        
        .btn-secondary {
            background-color: #757575;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #616161;
        }
        
        .btn-warning {
            background-color: #ff9800;
            color: white;
        }
        
        .btn-warning:hover {
            background-color: #f57c00;
        }
        
        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .error-message {
            background-color: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
            padding: 15px;
            border-radius: 3px;
            margin-bottom: 20px;
            font-size: 13px;
        }
        
        .info-message {
            background-color: #e3f2fd;
            border: 1px solid #2196f3;
            color: #1565c0;
            padding: 15px;
            border-radius: 3px;
            margin-bottom: 20px;
            font-size: 13px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        
        .progress-bar {
            background-color: #e0e0e0;
            height: 20px;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .progress-fill {
            background-color: #4caf50;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            font-weight: bold;
            transition: width 0.3s;
        }
        
        .question-block {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px dotted #ddd;
        }
        
        .question-number {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 8px;
        }
        
        .question-text {
            font-size: 13px;
            margin-bottom: 12px;
            line-height: 1.7;
        }
        
        .question-type-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: bold;
            background-color: #e3f2fd;
            padding: 3px 8px;
            margin-bottom: 8px;
            border: 1px solid #2196f3;
            color: #1976d2;
        }
        
        .options {
            margin-left: 20px;
            font-size: 13px;
        }
        
        .option {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            padding: 8px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        
        .option:hover {
            background-color: #f0f0f0;
        }
        
        .option.selected {
            background-color: #e3f2fd;
        }
        
        .score-box {
            background-color: #f0f0f0;
            border: 2px solid #000;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            font-size: 16px;
        }
        
        .score-box .score-number {
            font-size: 28px;
            font-weight: bold;
            color: #2196f3;
            margin-bottom: 10px;
        }
        
        .answer-review {
            border-left: 4px solid #4caf50;
            padding: 12px;
            margin-bottom: 15px;
            background-color: #f1f8f6;
        }
        
        .answer-review.incorrect {
            border-left-color: #f44336;
            background-color: #fef5f4;
        }
        
        .answer-status {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .answer-status.correct {
            color: #4caf50;
        }
        
        .answer-status.incorrect {
            color: #f44336;
        }
        
        .answer-detail {
            font-size: 12px;
            margin-bottom: 5px;
            line-height: 1.6;
        }
        
        #fileInput {
            display: none;
        }

        .loading-status {
            background-color: #fff3e0;
            border: 1px solid #ff9800;
            padding: 15px;
            border-radius: 3px;
            margin-bottom: 20px;
        }

        .loading-status h4 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #e65100;
        }

        .loading-status p {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="root">Loading...</div>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <script>
        const { useState, useRef, useEffect } = React;
        const { jsPDF } = window.jspdf;

        function SmartQuestionnaireSystem() {
            const [uploadedContent, setUploadedContent] = useState('');
            const [fileName, setFileName] = useState('');
            const [questions, setQuestions] = useState([]);
            const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
            const [userAnswers, setUserAnswers] = useState({});
            const [showResults, setShowResults] = useState(false);
            const [mode, setMode] = useState('upload');
            const [loading, setLoading] = useState(false);
            const [loadingStatus, setLoadingStatus] = useState('');
            const [error, setError] = useState('');
            const [questionConfig, setQuestionConfig] = useState({
                count: 20,
                difficulty: 'high',
                fontSize: 11,
                testTitle: 'Assessment Test',
                directions: 'Read each question carefully and select the best answer. Mark your answer by filling in the circle completely.',
                types: {
                    scenario: true,
                    analysis: true,
                    evaluation: true,
                    synthesis: true,
                    application: true
                }
            });
            const fileInputRef = useRef(null);

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setFileName(file.name);
                const text = await file.text();
                setUploadedContent(text);
                setMode('generate');
            };

            const generateQuestionsClientSide = async () => {
                setLoading(true);
                setError('');
                setLoadingStatus('Analyzing content and generating questions...');

                try {
                    const questionTypes = Object.keys(questionConfig.types).filter(
                        type => questionConfig.types[type]
                    );

                    // Simple client-side question generation
                    const generatedQuestions = await generateQuestionsFromContent(
                        uploadedContent,
                        questionConfig.count,
                        questionConfig.difficulty,
                        questionTypes
                    );

                    if (generatedQuestions.length === 0) {
                        throw new Error('Could not generate questions from the content. Please try a different file.');
                    }

                    setQuestions(generatedQuestions);
                    setMode('preview');
                    setLoadingStatus('');
                    setLoading(false);
                } catch (err) {
                    setError(err.message || 'Failed to generate questions. Please try again.');
                    setLoadingStatus('');
                    setLoading(false);
                }
            };

            // Client-side question generation logic
            const generateQuestionsFromContent = async (content, count, difficulty, types) => {
                setLoadingStatus('Parsing content...');
                
                // Extract key concepts and sentences from content
                const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 20);
                const paragraphs = content.split(/\n\n+/).filter(p => p.trim().length > 50);
                
                if (sentences.length < 5) {
                    throw new Error('Content is too short. Please upload a longer document.');
                }

                setLoadingStatus('Identifying key concepts...');
                
                const questions = [];
                const questionTemplates = getQuestionTemplates(difficulty);
                const usedContent = new Set();

                for (let i = 0; i < Math.min(count, sentences.length * 2); i++) {
                    setLoadingStatus(`Generating question ${i + 1} of ${count}...`);
                    
                    const type = types[i % types.length];
                    const template = questionTemplates[type][Math.floor(Math.random() * questionTemplates[type].length)];
                    
                    // Find unused content
                    let baseSentence;
                    let attempts = 0;
                    do {
                        baseSentence = sentences[Math.floor(Math.random() * sentences.length)].trim();
                        attempts++;
                    } while (usedContent.has(baseSentence) && attempts < 10);
                    
                    if (attempts >= 10 && usedContent.has(baseSentence)) continue;
                    
                    usedContent.add(baseSentence);
                    
                    const question = createQuestionFromTemplate(
                        template,
                        baseSentence,
                        type,
                        i + 1,
                        paragraphs
                    );
                    
                    if (question) {
                        questions.push(question);
                    }
                    
                    if (questions.length >= count) break;
                }

                return questions.slice(0, count);
            };

            const getQuestionTemplates = (difficulty) => {
                return {
                    scenario: [
                        { pattern: 'scenario_application', stem: 'Given the following scenario' },
                        { pattern: 'case_analysis', stem: 'Consider this situation' },
                        { pattern: 'real_world', stem: 'In a real-world context' }
                    ],
                    analysis: [
                        { pattern: 'compare', stem: 'Based on the information' },
                        { pattern: 'breakdown', stem: 'Analyzing the concept' },
                        { pattern: 'examine', stem: 'Upon examination of the material' }
                    ],
                    evaluation: [
                        { pattern: 'judge', stem: 'Evaluating the approach' },
                        { pattern: 'assess', stem: 'Considering the effectiveness' },
                        { pattern: 'critique', stem: 'From a critical perspective' }
                    ],
                    synthesis: [
                        { pattern: 'combine', stem: 'Integrating multiple concepts' },
                        { pattern: 'create', stem: 'Synthesizing the information' },
                        { pattern: 'design', stem: 'Based on the principles discussed' }
                    ],
                    application: [
                        { pattern: 'apply', stem: 'Applying this knowledge' },
                        { pattern: 'implement', stem: 'In practical implementation' },
                        { pattern: 'use', stem: 'Using the concepts presented' }
                    ]
                };
            };

            const createQuestionFromTemplate = (template, baseSentence, type, number, paragraphs) => {
                const words = baseSentence.split(' ').filter(w => w.length > 3);
                if (words.length < 5) return null;

                // Extract key terms
                const keyTerm = words[Math.floor(Math.random() * Math.min(words.length, 5))];
                
                // Create context
                const relatedParagraph = paragraphs.find(p => p.includes(keyTerm)) || baseSentence;
                const stem = `${template.stem}: "${relatedParagraph.substring(0, 200)}${relatedParagraph.length > 200 ? '...' : ''}"`;
                
                // Generate question based on type
                const questionText = generateQuestionText(type, keyTerm, baseSentence);
                
                // Generate plausible options
                const correctAnswer = generateCorrectAnswer(type, keyTerm, baseSentence);
                const distractors = generateDistractors(type, keyTerm, correctAnswer, words);
                
                const options = shuffleArray([correctAnswer, ...distractors]);
                const correctIndex = options.indexOf(correctAnswer);
                
                return {
                    number,
                    type,
                    stem,
                    question: questionText,
                    options,
                    correctIndex,
                    explanation: `The correct answer relates to the key concept of ${keyTerm} as presented in the material.`
                };
            };

            const generateQuestionText = (type, keyTerm, sentence) => {
                const templates = {
                    scenario: `How would you apply the concept of ${keyTerm} in this context?`,
                    analysis: `What is the most critical aspect of ${keyTerm} based on the information provided?`,
                    evaluation: `Which statement best evaluates the effectiveness of ${keyTerm}?`,
                    synthesis: `How can the principle of ${keyTerm} be integrated with other concepts?`,
                    application: `In what way would ${keyTerm} be most appropriately applied?`
                };
                return templates[type] || `What is the significance of ${keyTerm}?`;
            };

            const generateCorrectAnswer = (type, keyTerm, sentence) => {
                const words = sentence.split(' ');
                const context = words.slice(0, Math.min(15, words.length)).join(' ');
                return `It demonstrates ${keyTerm} through ${context.substring(0, 60)}...`;
            };

            const generateDistractors = (type, keyTerm, correctAnswer, words) => {
                const distractors = [
                    `It primarily focuses on an unrelated aspect of ${words[0] || 'the topic'}`,
                    `It contradicts the fundamental principles of ${keyTerm}`,
                    `It represents a common misconception about ${words[words.length - 1] || 'the concept'}`
                ];
                return distractors;
            };

            const shuffleArray = (array) => {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            };

            const downloadPDF = () => {
                const doc = new jsPDF();
                const fontSize = questionConfig.fontSize;
                const lineHeight = fontSize * 0.4;
                let yPosition = 20;
                const pageHeight = doc.internal.pageSize.height;
                const margin = 20;
                const maxWidth = 170;

                const checkAndAddPage = (requiredSpace) => {
                    if (yPosition + requiredSpace > pageHeight - margin) {
                        doc.addPage();
                        yPosition = 20;
                        return true;
                    }
                    return false;
                };

                doc.setFontSize(fontSize + 6);
                doc.setFont('helvetica', 'bold');
                doc.text(questionConfig.testTitle, 105, yPosition, { align: 'center' });
                yPosition += lineHeight * 2;

                doc.setFontSize(fontSize - 1);
                doc.setFont('helvetica', 'normal');
                doc.text('Name: _________________________________', margin, yPosition);
                doc.text('Date: _____________', 140, yPosition);
                yPosition += lineHeight * 1.5;
                doc.text('Section: _________________________________', margin, yPosition);
                yPosition += lineHeight * 2;

                if (questionConfig.directions) {
                    doc.setFont('helvetica', 'bold');
                    doc.text('DIRECTIONS:', margin, yPosition);
                    yPosition += lineHeight * 1.2;
                    doc.setFont('helvetica', 'normal');
                    const directionLines = doc.splitTextToSize(questionConfig.directions, maxWidth);
                    directionLines.forEach(line => {
                        checkAndAddPage(lineHeight * 1.2);
                        doc.text(line, margin, yPosition);
                        yPosition += lineHeight * 1.2;
                    });
                    yPosition += lineHeight;
                }

                questions.forEach((q) => {
                    checkAndAddPage(lineHeight * 10);

                    doc.setFontSize(fontSize);
                    doc.setFont('helvetica', 'bold');
                    doc.text(`${q.number}. [${q.type.toUpperCase()}]`, margin, yPosition);
                    yPosition += lineHeight * 1.3;

                    doc.setFont('helvetica', 'normal');
                    const stemLines = doc.splitTextToSize(q.stem, maxWidth);
                    stemLines.forEach(line => {
                        checkAndAddPage(lineHeight * 1.2);
                        doc.text(line, margin, yPosition);
                        yPosition += lineHeight * 1.2;
                    });
                    yPosition += lineHeight * 0.5;

                    doc.setFont('helvetica', 'bold');
                    const questionLines = doc.splitTextToSize(q.question, maxWidth);
                    questionLines.forEach(line => {
                        checkAndAddPage(lineHeight * 1.2);
                        doc.text(line, margin, yPosition);
                        yPosition += lineHeight * 1.2;
                    });
                    yPosition += lineHeight * 0.5;

                    doc.setFont('helvetica', 'normal');
                    q.options.forEach((option, optIdx) => {
                        checkAndAddPage(lineHeight * 2);
                        const optionLabel = String.fromCharCode(65 + optIdx);
                        doc.circle(margin + 2, yPosition - 1, 1.5);
                        const optionLines = doc.splitTextToSize(`${optionLabel}. ${option}`, maxWidth - 10);
                        optionLines.forEach((line, lineIdx) => {
                            if (lineIdx > 0) checkAndAddPage(lineHeight * 1.2);
                            doc.text(line, margin + 8, yPosition);
                            yPosition += lineHeight * 1.2;
                        });
                    });
                    yPosition += lineHeight * 1.5;
                });

                doc.save(`${questionConfig.testTitle.replace(/\s+/g, '_')}.pdf`);
            };

            const startOnlineTest = () => {
                setMode('take');
                setCurrentQuestionIndex(0);
                setUserAnswers({});
                setShowResults(false);
            };

            const handleAnswer = (questionIndex, optionIndex) => {
                setUserAnswers({
                    ...userAnswers,
                    [questionIndex]: optionIndex
                });
            };

            const submitQuestionnaire = () => {
                setShowResults(true);
                setMode('results');
            };

            const calculateScore = () => {
                let correct = 0;
                questions.forEach((q, idx) => {
                    if (userAnswers[idx] === q.correctIndex) {
                        correct++;
                    }
                });
                return correct;
            };

            const resetQuestionnaire = () => {
                setQuestions([]);
                setUserAnswers({});
                setShowResults(false);
                setCurrentQuestionIndex(0);
                setMode('upload');
                setUploadedContent('');
                setFileName('');
                setError('');
                setLoadingStatus('');
            };

            const exportResults = () => {
                const score = calculateScore();
                const results = {
                    fileName,
                    totalQuestions: questions.length,
                    score,
                    percentage: ((score / questions.length) * 100).toFixed(1),
                    answers: questions.map((q, idx) => ({
                        question: q.number,
                        type: q.type,
                        userAnswer: q.options[userAnswers[idx]] || 'Not answered',
                        correctAnswer: q.options[q.correctIndex],
                        isCorrect: userAnswers[idx] === q.correctIndex
                    }))
                };

                const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `questionnaire-results-${Date.now()}.json`;
                a.click();
            };

            // UPLOAD MODE
            if (mode === 'upload') {
                return React.createElement('div', { style: { backgroundColor: '#f5f5f5', minHeight: '100vh', padding: '20px' } },
                    React.createElement('div', { className: 'container' },
                        React.createElement('div', { className: 'header' },
                            React.createElement('h1', null, 'Smart Questionnaire Generator'),
                            React.createElement('p', { style: { fontSize: '12px', color: '#666', marginTop: '10px' } }, 'ðŸ”’ 100% Private - All processing happens in your browser')
                        ),
                        React.createElement('div', { className: 'upload-section' },
                            React.createElement('div', {
                                className: 'upload-box',
                                onClick: () => fileInputRef.current && fileInputRef.current.click()
                            },
                                React.createElement('h2', null, 'Upload Content File'),
                                React.createElement('p', null, 'Click to browse or drag and drop your .md, .markdown, or .txt file here'),
                                React.createElement('p', null, 'Supports educational content, lecture notes, study materials, etc.'),
                                React.createElement('input', {
                                    ref: fileInputRef,
                                    type: 'file',
                                    id: 'fileInput',
                                    accept: '.md,.markdown,.txt',
                                    onChange: handleFileUpload
                                })
                            )
                        )
                    )
                );
            }

            // GENERATE MODE
            if (mode === 'generate') {
                return React.createElement('div', { style: { backgroundColor: '#f5f5f5', minHeight: '100vh', padding: '20px' } },
                    React.createElement('div', { className: 'container' },
                        React.createElement('div', { className: 'header' },
                            React.createElement('h1', null, 'Configure Questionnaire')
                        ),
                        React.createElement('div', { className: 'info-message' },
                            'ðŸ”’ Your content stays private - all question generation happens locally in your browser without sending data to any server.'
                        ),
                        error && React.createElement('div', { className: 'error-message' }, error),
                        React.createElement('div', { style: { marginBottom: '20px', padding: '15px', backgroundColor: '#f0f0f0', border: '1px solid #ccc', borderRadius: '3px' } },
                            React.createElement('p', { style: { fontSize: '13px' } },
                                React.createElement('strong', null, 'Uploaded File: '),
                                fileName
                            )
                        ),
                        React.createElement('div', { className: 'config-section' },
                            React.createElement('div', { className: 'config-field' },
                                React.createElement('label', null, 'Test Title:'),
                                React.createElement('input', {
                                    type: 'text',
                                    value: questionConfig.testTitle,
                                    onChange: (e) => setQuestionConfig({...questionConfig, testTitle: e.target.value})
                                })
                            ),
                            React.createElement('div', { className: 'config-field' },
                                React.createElement('label', null, 'Number of Questions:'),
                                React.createElement('input', {
                                    type: 'number',
                                    min: '5',
                                    max: '50',
                                    value: questionConfig.count,
                                    onChange: (e) => setQuestionConfig({...questionConfig, count: Math.min(50, Math.max(5, parseInt(e.target.value) || 5))})
                                })
                            ),
                            React.createElement('div', { className: 'config-field' },
                                React.createElement('label', null, 'Difficulty Level:'),
                                React.createElement('select', {
                                    value: questionConfig.difficulty,
                                    onChange: (e) => setQuestionConfig({...questionConfig, difficulty: e.target.value})
                                },
                                    React.createElement('option', { value: 'medium' }, 'Medium (Analysis & Application)'),
                                    React.createElement('option', { value: 'high' }, 'High (Evaluation & Synthesis)'),
                                    React.createElement('option', { value: 'mixed' }, 'Mixed (All Levels)')
                                )
                            ),
                            React.createElement('div', { className: 'config-field' },
                                React.createElement('label', null, 'PDF Font Size:'),
                                React.createElement('select', {
                                    value: questionConfig.fontSize,
                                    onChange: (e) => setQuestionConfig({...questionConfig, fontSize: parseInt(e.target.value)})
                                },
                                    React.createElement('option', { value: '9' }, '9pt (Small)'),
                                    React.createElement('option', { value: '10' }, '10pt'),
                                    React.createElement('option', { value: '11' }, '11pt (Recommended)'),
                                    React.createElement('option', { value: '12' }, '12pt (Standard)'),
                                    React.createElement('option', { value: '14' }, '14pt (Large)')
                                )
                            )
                        ),
                        React.createElement('div', { className: 'config-field', style: { marginBottom: '20px' } },
                            React.createElement('label', null, 'Test Directions:'),
                            React.createElement('textarea', {
                                value: questionConfig
